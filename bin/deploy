#!/usr/bin/env bash

args=("$@")
#echo "${#args[@]} args: '${args[@]}'"

function remove_arg() {
    local target="$1"
    local args_without_target=()

    local removed="false"
    for arg in ${args[@]}; do
        if [[ "${arg}" != "${target}" ]] || [[ "${removed}" == "true" ]]; then
            args_without_target+=("${arg}")
        else
            removed="true"
        fi
    done

    args=("${args_without_target[@]}")
}

# bash 4.x is required
# TODO check bash version
#echo BASH_VERSION: $BASH_VERSION
#if [[ -z "${BASH_VERSION}" ]]; then (>&2 echo "source this script will expose variables to you session."); fi

# see: https://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash
# brew install gnu-opt, add 'export PATH="/usr/local/opt/gnu-getopt/bin:$PATH"' in ~/.profile and ~/.zshrc
! getopt --test > /dev/null
if [[ ${PIPESTATUS[0]} -ne 4 ]]; then (>&2 echo "'[ERROR] getopt --test' failed in this environment."); exit 1; fi

OPTIONS=ac:sv
LONGOPTS=all,commit:,short,verbose

# -use ! and PIPESTATUS to get exit code with errexit set
# -temporarily store output to be able to check for errors
# -activate quoting/enhanced mode (e.g. by writing out “--options”)
# -pass arguments only via   -- "$@"   to separate them correctly
! PARSED=$(getopt --quiet --options=${OPTIONS} --longoptions=${LONGOPTS} --name "$0" -- "$@")
if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
    # e.g. return value is 1
    # then getopt has complained about wrong arguments to stdout
    #exit 2
    # see: https://stackoverflow.com/questions/7663481/trapping-getopt-invalid-options
    getopt_err_msg=$(getopt --options=${OPTIONS} --longoptions=${LONGOPTS} --name "$0" -- "$@" 2>&1 1>&-)
    (>&2 echo "ignore invalid options, message: '${getopt_err_msg}'")
fi
# read getopt’s output this way to handle the quoting right:
eval set -- "${PARSED}"

pass_through=()
opt_all="" opt_commit="" opt_short="" opt_verbose=""
# now enjoy the options in order and nicely split until we see --
while true; do
    case "$1" in
        -a|--all)
            opt_all="true"
            shift
            remove_arg "-a"
            remove_arg "--all"
        ;;
        -c|--commit)
            opt_commit="$2"
            shift 2
            remove_arg "-c"
            remove_arg "--commit"
            remove_arg "$opt_commit"
        ;;
        -s|--short)
            opt_short="true"
            shift
            remove_arg "-s"
            remove_arg "--short"
        ;;
        -v|--verbose)
            opt_verbose="true"
            shift
            remove_arg "-v"
            remove_arg "--verbose"
        ;;
        --)
            shift
            break
        ;;
        *)
            # should not reach here
        ;;
    esac
done

sourced_or_run=""
if [[ $0 != $BASH_SOURCE ]]; then sourced_or_run="sourced"; else sourced_or_run="run"; fi

if [[ "${sourced_or_run}" == "run" ]]; then
    set -o errexit -o pipefail -o noclobber
    #-o nounset

    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo -e "\n# >>>>>>>>>>>>>>>>>>>> options and commands >>>>>>>>>>>>>>>>>>>>"); fi
    # handle non-option arguments
    if [[ $# -gt 0 ]]; then
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "$# non-option arguments: '$@'"); fi;

        if [[ $# -gt 2 ]] && [[ "$1" == "docker-compose" ]] && [[ "$3" == "down" ]]; then
            if [[ "${opt_verbose}" == "true" ]]; then args+=("-v"); fi
        fi
    fi

    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "${#args[@]} args: '${args[@]}'"); fi
    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "opt_all: '${opt_all}', opt_commit: '${opt_commit}', opt_short: '${opt_short}', opt_verbose: '${opt_verbose}'"); fi

    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "script is being run"); fi
    # see: https://stackoverflow.com/questions/59895/getting-the-source-directory-of-a-bash-script-from-within
    SOURCE="${BASH_SOURCE[0]}"
else
    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "script is being sourced"); fi
    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "source this script will expose variables to you session."); fi
    if [[ "$BASH_SOURCE" == /* ]] || [[ "$BASH_SOURCE" == ~/* ]]; then SOURCE="$BASH_SOURCE"; else SOURCE="$(pwd)/$BASH_SOURCE"; fi
fi
if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "SOURCE: '${SOURCE}'"); fi
while [[ -h "${SOURCE}" ]]; do # resolve ${SOURCE} until the file is no longer a symlink
    DIR="$( cd -P "$( dirname "${SOURCE}" )" >/dev/null && pwd )"
    SOURCE="$(readlink "${SOURCE}")"
    [[ ${SOURCE} != /* ]] && SOURCE="${DIR}/${SOURCE}" # if ${SOURCE} was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
DIR="$(dirname $( cd -P "$( dirname "${SOURCE}" )" >/dev/null && pwd ))"
if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "DIR: '${DIR}'"); fi

if [[ -z "${DEPLOY_BIN:-}" ]]; then DEPLOY_BIN="${DIR}/bin"; fi
if [[ -z "${DEPLOY_DOT_CONFIG_ENVIRONMENT:-}" ]]; then DEPLOY_DOT_CONFIG_ENVIRONMENT="${DIR}/.config/environment"; fi
if [[ -z "${DEPLOY_DOT_CONFIG_ENVIRONMENTS:-}" ]]; then DEPLOY_DOT_CONFIG_ENVIRONMENTS="${DIR}/.config/environments"; fi
if [[ -z "${DEPLOY_INSTANCES:-}" ]]; then DEPLOY_INSTANCES="${DIR}/instances"; fi
if [[ -z "${DEPLOY_LIBS:-}" ]]; then DEPLOY_LIBS="${DIR}/libs"; fi


source ${DEPLOY_LIBS}/os.sh
PATH="/usr/local/bin:${PATH}"

if [[ -z "${CMD_DOCKER:-}" ]]; then CMD_DOCKER=$(which docker || echo ''); fi
if [[ -z "${CMD_DOCKER_COMPOSE:-}" ]]; then CMD_DOCKER_COMPOSE=$(which docker-compose || echo ''); fi
ARIA2C_DOWNLOAD="aria2c --file-allocation=none -c -x 10 -s 10 -m 0 --console-log-level=notice --log-level=notice --summary-interval=0"


# arguments: target, ownership, permissions
function chown_chmod() {
    local target="$1"
    local ownership="$2"
    local permissions="$3"
    local is_root=$(if [[ "$(whoami)" == "root" ]]; then echo "true"; else echo "false"; fi)
    if [[ "${is_root}" == "true" ]]; then
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo ls -la ${target}); fi
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 ls -la ${target}); fi
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo chown ${ownership} ${target}); fi
        chown ${ownership} ${target}
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo chmod ${permissions} ${target}); fi
        chmod ${permissions} ${target}
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo ls -la ${target}); fi
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 ls -la ${target}); fi
    else
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo sudo ls -la ${target}); fi
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 sudo ls -la ${target}); fi
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo sudo chown ${ownership} ${target}); fi
        sudo chown ${ownership} ${target}
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo sudo chmod ${permissions} ${target}); fi
        sudo chmod ${permissions} ${target}
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo sudo ls -la ${target}); fi
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 sudo ls -la ${target}); fi
    fi
}

# arguments: url, target_dir, target_file, overwrite, optional
function download() {
    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo -e "\n    # >>>>>>>>>>>>>>>>>>>> download >>>>>>>>>>>>>>>>>>>>"); fi

    local url="$1"
    local target_dir="$2"
    local target_file="$3"
    local overwrite="$4"
    local optional="$5"

    local aria2="aria2c --file-allocation=none -c -x 10 -s 10 -m 0 --console-log-level=notice --log-level=notice --summary-interval=0"
    local aria2_options=""
    local curl="curl -sSL"
    local curl_options=""
    if [[ -n "${CI_OPT_GIT_AUTH_TOKEN}" ]]; then
        aria2_options=" --header=\"PRIVATE-TOKEN: ${CI_OPT_GIT_AUTH_TOKEN}\""
        curl_options=" -H \"PRIVATE-TOKEN: ${CI_OPT_GIT_AUTH_TOKEN}\""
    else
        (>&2 echo "CI_OPT_GIT_AUTH_TOKEN not found. The download (${url}) may fail without CI_OPT_GIT_AUTH_TOKEN.")
    fi
    aria2="${aria2}${aria2_options}"
    curl="${curl}${curl_options}"

    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "    download ${url} to ${target_dir}/${target_file}, overwrite: ${overwrite}"); fi
    if [[ "${overwrite}" == "true" ]]; then rm -f ${target_dir}/${target_file}; fi
    if [[ "${overwrite}" == "true" ]] || [[ ! -f ${target_dir}/${target_file} ]]; then
        if [[ "$(is_remote_resource_exists "${url}" "${curl_options}")" == "true" ]]; then
            #(>&2 echo "    "${curl} -o ${target_dir}/${target_file} "${url}")
            if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo ${aria2} -d ${target_dir} -o ${target_file} ${url}); fi
            #(>&2 echo "    "which aria2c $(which aria2c))
            (>&2 sh -c "${aria2} -d ${target_dir} -o ${target_file} ${url}")
        elif [[ "${optional}" == "true" ]]; then
            (>&2 echo "[WARN] can not download optional resource ${url}")
        else
            (>&2 echo "[ERROR] can not download resource ${url}")
            return 1
        fi
    else
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "    update == false or file (${target_dir}/${target_file}) already exists, skip download."); fi
    fi
    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo -e "    # <<<<<<<<<<<<<<<<<<<< download <<<<<<<<<<<<<<<<<<<<\n"); fi
}

# arguments: $1 local repository, $2 commit
function git_checkout() {
    local local_repo="$1"
    local commit="$2"

    if [[ -n "${commit}" ]]; then
        sudo chown -R ${USER} ${local_repo}

        local current_branch=$(git -C ${local_repo} symbolic-ref -q --short HEAD || echo error)

        # remove untracked files and directories
        git -C ${local_repo} clean -fd :/
        git -C ${local_repo} checkout -- . 2>&1 > /dev/null
        git -C ${local_repo} checkout master 2>&1 > /dev/null
        git -C ${local_repo} fetch --all 2>&1 > /dev/null
        git -C ${local_repo} reset --hard origin/master 2>&1 > /dev/null
        git -C ${local_repo} remote update origin --prune

        if [[ "${commit}" == "latest" ]]; then
            if [[ "${current_branch}" != "error" ]]; then
                if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "fetch and reset latest ${local_repo} ${current_branch}"); fi
                git -C ${local_repo} pull origin ${current_branch} 2>&1 > /dev/null
            else
                if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "fetch and reset latest ${local_repo}, not on a branch"); fi
            fi
        else
            if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "fetch and checkout ${commit} ${local_repo}"); fi
            git -C ${local_repo} checkout -f ${commit} 2>&1 > /dev/null
        fi

        (>&2 git -C ${local_repo} status)
    fi
}

function install_on_ubuntu() {
    # add into PATH
    #if [[ -f ~/.profile ]] && ! grep -q "${DEPLOY_BIN}" ~/.profile; then sed -i "1iexport PATH=\"${DEPLOY_BIN}:\$PATH\"\n" ~/.profile; fi
    if [[ ! -L /usr/local/bin/deploy  ]]; then sudo ln -s ${DEPLOY_BIN}/deploy /usr/local/bin/deploy; fi

    # Bash completion scripts in: /usr/local/etc/bash_completion.d
    if [[ -d /etc/bash_completion.d ]] && [[ ! -L /etc/bash_completion.d/deploy ]]; then
        sudo ln -s ${DEPLOY_LIBS}/bash_completion.d/deploy /etc/bash_completion.d/deploy;
    fi

    sudo apt -y update;
    if ! type -p /usr/bin/aria2c > /dev/null ; then sudo apt -y install aria2; fi
    sudo apt -y install bzip2 ca-certificates curl git jq software-properties-common tar unzip zip;
    # sudo apt -y remove docker docker-engine docker.io
    if ! type -p /usr/bin/docker > /dev/null; then
        #curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
        sudo apt-key add ${DEPLOY_LIBS}/docker_ubuntu_gpg
        #export APT_REPOSITORY_DOCKER="https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu"
        sudo add-apt-repository "deb [arch=amd64] ${APT_REPOSITORY_DOCKER:-https://download.docker.com/linux/ubuntu} $(lsb_release -cs) stable"
        #sudo add-apt-repository "deb [arch=amd64] ${APT_REPOSITORY_DOCKER:-https://download.docker.com/linux/ubuntu} $(lsb_release -cs) edge"
        #sudo add-apt-repository "deb [arch=amd64] ${APT_REPOSITORY_DOCKER:-https://download.docker.com/linux/ubuntu} $(lsb_release -cs) nightly"
        sudo apt -y update
        sudo apt-cache madison docker-ce
        sudo apt -yq install docker-ce=${IMAGE_ARG_DOCKERCE_VERSION:-18.06.1~ce~3-0}~ubuntu
        sudo service docker start
    fi

    if [[ ! -w /var/run/docker.sock ]]; then
        sudo chown root:docker /var/run/docker.sock
        sudo chmod 777 /var/run/docker.sock
        sudo usermod -a -G docker $(whoami) || echo "useradd: user 'sysop' already exists"
    fi

    if [[ ! -f /usr/local/bin/docker-compose ]]; then
        #sudo curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose
        sudo ${ARIA2C_DOWNLOAD} -d /usr/local/bin -o docker-compose https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m`
        sudo chown root:$(whoami) /usr/local/bin/docker-compose
        sudo chmod 775 /usr/local/bin/docker-compose
    fi
}

# arguments: $1: instance (host/service/instance_name or instance_name.service)
# returns: 0 if standalone instance, 1 if not standalone instance
function is_standalone_instance() {
    local instance="$(normalize-instance "$1")"
    local instance_name=$(echo ${instance} | awk -F/ '{print $3}')
    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "instance_name: '${instance_name}'"); fi

    local environment="$(environment)"
    if [[ "${instance_name}" == "standalone" ]]; then return 0; else return 1; fi
}

# arguments: $1: instance (host/service/instance_name or instance_name.service)
# returns: 0 if valid, 1 if not valid
function is_instance_config_exist() {
    local instance_properties="$(instance-properties "$1")"
    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "is_instance_config_exist instance: '$1', instance_properties: '${instance_properties}'"); fi
    if [[ -f "${instance_properties}" ]]; then return 0; else return 1; fi
}

# arguments: curl_source, curl_option
function is_remote_resource_exists() {
    local curl_source="$1"
    local curl_default_options="-H \"Cache-Control: no-cache\" -s -t utf-8"
    local curl_option="$2 ${curl_default_options}"
    local curl_secret="$(echo $2 | sed -E "s#: [^ ]+#: <secret>'#g") ${curl_default_options}"
    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "Test whether remote file exists: curl -I -o /dev/null -w \"%{http_code}\" ${curl_secret} ${curl_source} | tail -n1"); fi
    local status_code=$(sh -c "curl -I -o /dev/null -w \"%{http_code}\" ${curl_option} ${curl_source} | tail -n1 || echo -n 500")
    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "status_code: ${status_code}"); fi
    if [[ "200" == "${status_code}" ]]; then echo "true"; else echo "false"; fi
}

# arguments: $1: command
# returns: 0 if valid, 1 if not valid
function is_valid_docker-compose_command() {
    local valid_commands=($(${CMD_DOCKER_COMPOSE} help | awk 'x==1 {print $1} /^Commands:/ {x=1}'))
    for command in ${valid_commands[@]}; do
        if [[ "${command}" == "$1" ]]; then return 0; fi
    done
    return 1
}

# arguments: $1: command
# returns: 0 to update, 1 not to update
function update_instance_config() {
    local command="$1"
    if [[ "${DEPLOY_UPDATE_INSTANCE_CONFIG}" == "true" ]]; then return 0; elif [[ "${command}" == "up" ]]; then return 0; else return 1; fi
}

# arguments: $1: environment name
function clean() {
    local environment="$1"
    if [[ -z "${environment}" ]]; then environment="$(environment)"; fi
    sudo rm -rf "${DEPLOY_DOT_CONFIG_ENVIRONMENTS}/${environment}"
}

function commands() {
    #for c in ${_commands[@]}; do echo "${c}"; done
    if [[ ${#_commands[@]} -gt 0 ]]; then printf '%s\n' "${_commands[@]}" | sort; fi
}

# arguments: none
function current-host() {
    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo -e "\n# >>>>>>>>>>>>>>>>>>>> current-host >>>>>>>>>>>>>>>>>>>>"); fi

    local ip_addr=""

    if [[ -n "${DEPLOY_CURRENT_HOST_IPADDRESS}" ]]; then
        ip_addr="${DEPLOY_CURRENT_HOST_IPADDRESS}"
    else
        local environment="$(environment)"
        local local_environment_repo="${DEPLOY_DOT_CONFIG_ENVIRONMENTS}/${environment}"

        local ignored_interfaces=($(cat ${local_environment_repo}/environment.properties | grep SPRING_CLOUD_INETUTILS_IGNOREDINTERFACES | awk -F= '{print $2}' | tr ',' '\n' | sed -E 's#^[ ]+##'))
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "ignored_interfaces ${ignored_interfaces[@]}"); fi

        local interfaces_found=($(ifconfig | grep -Eo '^([a-zA-Z0-9]+)[:]? ' | sed -E 's#[:]?[ ]+##' | sort -r))
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "interfaces_found ${interfaces_found[@]}"); fi

        local interfaces=()
        for interface in ${interfaces_found[@]}; do
            for ignored_interface_regex in ${ignored_interfaces[@]}; do
                if [[ "${interface}" =~ ${ignored_interface_regex} ]]; then
                    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "ignore interface ${interface}, regex matched ${ignored_interface_regex}"); fi
                    # check next interface
                    continue 2
                fi
            done

            #(>&2 echo "candidate interface ${interface}")
            interfaces+=("${interface}")
        done
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "interfaces ${interfaces[@]}"); fi

        local preferred_networks=()
        if [[ -f "${local_environment_repo}/environment.properties" ]]; then
            preferred_networks=($(cat "${local_environment_repo}/environment.properties" | grep SPRING_CLOUD_INETUTILS_PREFERREDNETWORKS | awk -F= '{print $2}' | tr ',' '\n' | sed -E 's#^[ ]+##' | sed 's#\\\\#\\#g'))
        else
            preferred_networks+=("172\\..+")
            preferred_networks+=("10\\..+")
            preferred_networks+=("192\\..+")
            if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "${local_environment_repo}/environment.properties not found, using default preferred_networks '${preferred_networks[@]}'."); fi
        fi
        for preferred_network_regex in ${preferred_networks[@]}; do
            for interface in ${interfaces[@]}; do
                if [[ "$(os_kernel_name)" == "linux" ]]; then
                    # ubuntu 16.04 e.g.
                    #          inet addr:172.30.17.10  Bcast:172.30.17.255  Mask:255.255.255.0
                    #ip_addr=$(ifconfig | awk '/inet addr/{print substr($2,6)}' | sort -r | head -n1)
                    ip_addr=$(ifconfig ${interface} | awk '/inet addr/{print substr($2,6)}' | sort -r | head -n1 || echo '')
                    # ubuntu 18.04 e.g.
                    #        inet 172.30.0.236  netmask 255.255.255.0  broadcast 172.30.0.255
                    if [[ -z "${ip_addr}" ]]; then ip_addr=$(ifconfig ${interface} | awk '/inet/{print substr($2,1)}' | head -n1 || echo ''); fi
                elif [[ "$(os_kernel_name)" == "darwin" ]]; then
                    #ip_addr=$(ipconfig getifaddr en0 || ipconfig getifaddr en1)
                    ip_addr=$(ipconfig getifaddr ${interface} || echo '')
                else
                    #ip_addr=$(ifconfig | perl -nle 's/dr:(\S+)/print $1/e' | sort -r | head -n1)
                    ip_addr=$(ifconfig ${interface} | perl -nle 's/dr:(\S+)/print $1/e' | sort -r | head -n1 || echo '')
                fi

                if [[ -z "${ip_addr}" ]]; then
                    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "ip_addr not found on interface ${interface}"); fi
                    continue 1
                else
                    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "ip_addr ${ip_addr} found on interface ${interface}"); fi
                fi

                if [[ "${ip_addr}" =~ ${preferred_network_regex} ]]; then
                    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "prefer ip_addr ${ip_addr} on interface ${interface}, regex matched ${preferred_network_regex}"); fi
                    break 2
                else
                    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "ip_addr ${ip_addr} on interface ${interface}, regex not matched ${preferred_network_regex}"); fi
                fi
            done
        done
    fi

    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "current-host ${ip_addr}"); fi
    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo -e "# <<<<<<<<<<<<<<<<<<<< current-host <<<<<<<<<<<<<<<<<<<<\n"); fi

    if [[ -z "${ip_addr}" ]]; then (>&2 echo "[ERROR] error get DEPLOY_CURRENT_HOST_IPADDRESS, exit."); exit 1; fi
    echo "${ip_addr}"
}

# arguments: $1: instance (host/service/instance_name or instance_name.service), $2: docker-compose command, $3...: docker-compose command args
function docker-compose() {
    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo -e "\n# >>>>>>>>>>>>>>>>>>>> docker-compose >>>>>>>>>>>>>>>>>>>>"); fi

    local instance="$(normalize-instance "$1")"
    local command="$2"
    # TODO output version of environment repo (ref name and commit id)
    if ! is_instance_config_exist "${instance}" ; then (>&2 echo "[ERROR] properties not found for instance ${instance}"); exit 1; else shift 1; fi
    if ! is_valid_docker-compose_command "${command}" ; then (>&2 echo "[ERROR] invalid docker-compose command ${command}"); exit 1; else shift 1; fi

    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "instance: ${instance}, command: ${command}, args: $@"); fi

    instance-variables "${instance}"

    local update="false"
    if update_instance_config "${command}" ; then update="true"; fi

    local deploy_descriptors=($(instance-deploy-config "${instance}" "${update}"))
    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "deploy_descriptors: '${deploy_descriptors[@]}'"); fi
    if [[ -z "${deploy_descriptors[@]}" ]]; then (>&2 echo "[ERROR] no deploy descriptors found"); return 1; fi
    for deploy_descriptor in ${deploy_descriptors[@]}; do
        if [[ ! -f "${deploy_descriptor}" ]]; then (>&2 echo "[ERROR] deploy descriptor '${deploy_descriptor}' not found"); return 1; fi
    done

    local instance_dir="$(instance-dir "${instance}")"
    if [[ "${command}" == "up" ]]; then
        fix-permissions "${instance}"

        cd ${instance_dir}
        if [[ "${SKIP_IMAGE_UPDATE}" != "true" ]]; then
            if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo ${CMD_DOCKER_COMPOSE} -f ${deploy_descriptor} pull); fi
            ${CMD_DOCKER_COMPOSE} -f ${deploy_descriptor} pull
        fi
        cd -
    fi

    cd ${instance_dir}
    # ${@:3}
    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo ${CMD_DOCKER_COMPOSE} -f ${deploy_descriptor} ${command} $@); fi
    ${CMD_DOCKER_COMPOSE} -f ${deploy_descriptor} ${command} $@
    cd -

    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo -e "# <<<<<<<<<<<<<<<<<<<< docker-compose <<<<<<<<<<<<<<<<<<<<\n"); fi
}

function doctor() {
    _opt_all="${opt_all}"
    opt_all="true"

    local standalone_instances=($(search-standalone-instances))
    local duplicate_standalone_instances=()
    if [[ ${#standalone_instances[@]} -gt 0 ]]; then duplicate_standalone_instances=($(printf '%s\n' "${standalone_instances[@]}" | awk -F/ '{print $2}' | sort | uniq -d)); fi
    if [[ ${#duplicate_standalone_instances[@]} -gt 0 ]]; then
        (>&2 echo "[ERROR] found duplicate standalone instances for services ${duplicate_standalone_instances[@]}");
        for d in ${duplicate_standalone_instances[@]}; do printf '%s\n' "${standalone_instances[@]}" | grep ${d}; done;
        exit 1;
    fi

    local named_instances=($(search-named-instances))
    local duplicate_named_instances=()
    if [[ ${#standalone_instances[@]} -gt 0 ]]; then duplicate_named_instances=($(printf '%s\n' "${named_instances[@]}" | awk -F/ '{print $2"/"$3}' | sort | uniq -d)); fi
    if [[ ${#duplicate_named_instances[@]} -gt 0 ]]; then
        (>&2 echo "[ERROR] found duplicate names instances for services ${duplicate_named_instances[@]}");
        for d in ${duplicate_named_instances[@]}; do printf '%s\n' "${named_instances[@]}" | grep ${d}; done;
        exit 1;
    fi

    for named_instance in ${named_instances[@]}; do
        local instance_service="$(instance-service "${named_instance}")"
        local invalid_standalone_instances=($(printf '%s\n' "${standalone_instances[@]}" | grep "/${instance_service}/" | sort))
        if [[ ${#invalid_standalone_instances[@]} -gt 0 ]]; then
            (>&2 echo "[ERROR] found invalid standalone instances ${invalid_standalone_instances[@]}");
            (>&2 echo "found at least one named instance '${named_instance}' of service '${instance_service}'");
            (>&2 echo "all instances of ${instance_service} should be named")
            exit 1;
        fi
    done

    # TODO find out instances that should not on current host

    opt_all="${_opt_all}"
    echo "ok"
}

# get or set current working environment
# arguments: none (read), dir or environment repository or environment name (set)
function environment() {
    local environment=""
    if [[ -n "${DEPLOY_ENVIRONMENT:-}" ]]; then environment="${DEPLOY_ENVIRONMENT}"; elif [[ "$1" != "dir" ]]; then environment="$1"; fi
    if [[ -z "${environment}" ]] && [[ -f "${DEPLOY_DOT_CONFIG_ENVIRONMENT}" ]]; then environment="$(cat "${DEPLOY_DOT_CONFIG_ENVIRONMENT}" | grep -E .+ | head -n 1)"; fi

    local local_environment_repo="${DEPLOY_DOT_CONFIG_ENVIRONMENTS}/${environment}"

    if [[ -n "${environment}" ]]; then
        local environment_repo=""
        if [[ "${environment}" == *.git ]]; then
            environment_repo="${environment}"
            environment="$(echo ${environment_repo} | sed -E 's#.*/([^/]+).git#\1#')"
            local_environment_repo="${DEPLOY_DOT_CONFIG_ENVIRONMENTS}/${environment}"
        else
            environment_repo="$(git -C ${DIR} config --get remote.origin.url | sed 's#/[^/]*$##')/${environment}.git"
        fi

        if [[ ! -d ${local_environment_repo} ]]; then
            (>&2 mkdir -p ${DEPLOY_DOT_CONFIG_ENVIRONMENTS}; git clone ${environment_repo} ${local_environment_repo})
        elif [[ ! -d ${local_environment_repo}/.git ]]; then
            (>&2 echo "clone into non-empty directory")
            (>&2 cd ${local_environment_repo}; git init && git remote add origin ${environment_repo} && git fetch --all && git reset origin/master > /dev/null;)
        fi

        if ([[ -n "$1" ]] && [[ "$1" != "dir" ]]) || [[ -n "${opt_commit}" ]]; then
            git_checkout "${local_environment_repo}" "${opt_commit:-latest}"
        fi

        echo "${environment}" | tee "${DEPLOY_DOT_CONFIG_ENVIRONMENT}" > /dev/null
    fi

    if [[ -z "${environment}" ]]; then (>&2 echo "no environment specified"); fi
    if [[ "$1" == "dir" ]]; then
        echo "${local_environment_repo}"
    else
        echo "${environment}"
    fi
}

# list all environments in local repository
function environments() {
    local found=($(sudo find -L ${DEPLOY_DOT_CONFIG_ENVIRONMENTS} -maxdepth 2 -name ".git" -type d -printf '%P\n' | awk -F/ '{print $1}' | sort))
    if [[ ${#found[@]} -gt 0 ]]; then printf '%s\n' "${found[@]}"; fi
}

# fix ownership and permissions
# arguments: [$1: instance (host/service/instance_name or instance_name.service) or directory to fix, optional]
function fix-permissions() {
    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo -e "\n# >>>>>>>>>>>>>>>>>>>> fix-permissions >>>>>>>>>>>>>>>>>>>>"); fi

    local target_directory=""

    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "fix-permissions \$1 '$1'"); fi
    if [[ "$1" == /* ]]; then
        target_directory="$1";
    elif [[ -n "$1" ]]; then
        local instance="$(normalize-instance "$1")"
        local instance_dir="$(instance-dir "${instance}")"
        target_directory="${instance_dir}/data"
    fi
    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "fix-permissions target_directory '${target_directory}'"); fi

    if [[ -n "${target_directory}" ]] && [[ -f "${target_directory}/permissions" ]]; then
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "fix-permissions fix specific target_directory that contains 'permissions' file"); fi

        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "sudo find -L ${target_directory} -maxdepth 6 | sed 's#${target_directory}##' | sed 's#/##' | grep -Ev '^[ ]*$'"); fi
        local files_in_data=($(sudo find -L ${target_directory} -maxdepth 6 | sed "s#${target_directory}##" | sed 's#/##' | grep -Ev '^[ ]*$'))

        local config_file="${target_directory}/permissions"
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "permissions file ${config_file}"); fi
        if [[ ! -f ${config_file} ]]; then (>&2 echo "permissions file ${config_file} not found, skip"); return; fi

        local configs=($(cat ${config_file} | grep -Ev '^[ ]*$' | awk '{print $1","$2","$3","$4}'))
        for config in ${configs[@]}; do
            local type=$(echo ${config} | awk -F, '{print $1}')
            local name=$(echo ${config} | awk -F, '{print $2}')
            local ownership=$(echo ${config} | awk -F, '{print $3}')
            local permissions=$(echo ${config} | awk -F, '{print $4}')
            if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "name ${name}, ownership ${ownership}, permissions ${permissions}"); fi

            for found in ${files_in_data[@]}; do
                if [[ "${found}" == "${name}" ]]; then
                    chown_chmod "${target_directory}/${name}" "${ownership}" "${permissions}"
                    continue 2
                fi
            done

            if [[ "${type}" == "d" ]] && [[ ! -d ${target_directory}/${name} ]]; then
                if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo mkdir -p ${target_directory}/${name}); fi
                mkdir -p ${target_directory}/${name}

                chown_chmod "${target_directory}/${name}" "${ownership}" "${permissions}"
            fi
        done
    elif [[ -n "${target_directory}" ]] && [[ -d "${target_directory}" ]]; then
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "fix-permissions fix target_directories in '${target_directory}'"); fi

        # fix all target_directories
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "permissions_files=(\$(sudo find -L ${target_directory} -maxdepth 5 -type f -name permissions))"); fi
        local permissions_files=($(sudo find -L ${target_directory} -maxdepth 5 -type f -name permissions))
        local target_directories=()
        if [[ ${#permissions_files[@]} -gt 0 ]]; then target_directories=($(printf '%s\n' "${permissions_files[@]}" | xargs -i dirname {})); fi
        for element in ${target_directories[@]}; do
            if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "fix-permissions '${element}'"); fi
            fix-permissions "${element}"
        done
    elif [[ -z "${target_directory}" ]]; then
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "fix-permissions fix all directories in ${DIR}"); fi

        fix-permissions "${DIR}"
    else
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "fix-permissions target_directory '${target_directory}' not found"); fi
    fi

    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo -e "# <<<<<<<<<<<<<<<<<<<< fix-permissions <<<<<<<<<<<<<<<<<<<<\n"); fi
}

function install() {
    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo -e "\n\n# >>>>>>>>>>>>>>>>>>>> install >>>>>>>>>>>>>>>>>>>>"); fi

    if [[ "$(os_description)" == "Ubuntu" ]]; then
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "install on Ubuntu"); fi

        install_on_ubuntu
    elif [[ "$(os_description)" == "OSX" ]]; then
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "install on OSX"); fi

        if ! type -p /usr/local/bin/brew > /dev/null ; then /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"; fi
        # OSX with homebrew, bash 4.x, bash-completion@2
        if ! type -p /usr/local/bin/bash > /dev/null ; then brew install bash; fi
        if ! type -p /usr/local/bin/aria2c > /dev/null ; then brew install aria2; fi
        if [[ ! -f /usr/local/share/bash-completion/bash_completion ]]; then brew install bash-completion@2; fi
        if [[ ! -d /usr/local/share/zsh-completions ]]; then brew install zsh-completions; fi

        if ! type -p /usr/local/bin/jq > /dev/null ; then brew install jq; fi

        # add into PATH
        #if [[ -f ~/.profile ]] && ! grep -q "${DEPLOY_BIN}" ~/.profile; then sed -i "1iexport PATH=\"${DEPLOY_BIN}:\$PATH\"\n" ~/.profile; fi
        #if [[ -f ~/.zshrc ]] && ! grep -q "${DEPLOY_BIN}" ~/.zshrc; then echo -e "\nexport PATH=\"${DEPLOY_BIN}:\$PATH\"\n" | tee -a ~/.zshrc > /dev/null; fi
        if [[ ! -L /usr/local/bin/deploy ]]; then ln -s ${DEPLOY_BIN}/deploy /usr/local/bin/deploy; fi

        # Add 'if [[ -f /usr/local/share/bash-completion/bash_completion ]]; then . /usr/local/share/bash-completion/bash_completion; fi' into ~/.profile
        if [[ -f ~/.profile ]] && ! grep -q "/usr/local/share/bash-completion/bash_completion" ~/.profile; then
            echo -e "\nif [[ -f /usr/local/share/bash-completion/bash_completion ]]; then . /usr/local/share/bash-completion/bash_completion; fi\n" | tee -a ~/.profile > /dev/null;
        fi

        # Bash completion scripts in: /usr/local/etc/bash_completion.d
        if [[ -d /usr/local/etc/bash_completion.d ]] && [[ ! -L /usr/local/etc/bash_completion.d/deploy ]]; then
            ln -s ${DEPLOY_LIBS}/bash_completion.d/deploy /usr/local/etc/bash_completion.d/deploy;
        fi

        # Add 'fpath=(/usr/local/share/zsh-completions $fpath)\nfpath=(/usr/local/share/zsh/site-functions $fpath)\ncompinit' into ~/.zshrc
        # Zsh completion scripts in: /usr/local/share/zsh/site-functions
        if [[ -d /usr/local/share/zsh/site-functions ]] && [[ ! -L /usr/local/share/zsh/site-functions/_deploy ]]; then
            ln -s ${DEPLOY_LIBS}/zsh/site-functions/_deploy /usr/local/share/zsh/site-functions/_deploy;
        fi
    fi

    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo -e "# <<<<<<<<<<<<<<<<<<<< install <<<<<<<<<<<<<<<<<<<<\n"); fi
}

# arguments: $1: instance (host/service/instance_name or instance_name.service), [$2 update (true/false, optional, default false)]
# returns: files
function instance-deploy-config() {
    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo -e "\n\n# >>>>>>>>>>>>>>>>>>>> instance-deploy-config >>>>>>>>>>>>>>>>>>>>"); fi

    local instance="$(normalize-instance "$1")"
    local update="$2"
    if [[ -z "${update}" ]]; then update="false"; fi

    local instance_dir="$(instance-dir "${instance}")"

    local instance_properties_dir="$(instance-properties-dir "${instance}")"
    fix-permissions "${instance_properties_dir}"
    if [[ ! -d "${instance_dir}" ]]; then mkdir -p "${instance_dir}"; fi

    local instance_service="$(instance-service "${instance}")"
    local compose_service_filename="docker-compose_${instance_service}.yml"

    local deploy_descriptor_path="$(instance-variables "${instance}" "DEPLOY_DESCRIPTOR_PATH")"
    local _deploy_descriptor_files="$(instance-variables "${instance}" "DEPLOY_DESCRIPTOR_FILES")"
    IFS=',' read -a deploy_descriptor_files <<< "${_deploy_descriptor_files}"

    if [[ "${deploy_descriptor_path}" == http* ]]; then
    # http: or https:
        if [[ ${#deploy_descriptor_files[@]} -eq 0 ]]; then
            deploy_descriptor_files+=("docker-compose-base.yml")
            deploy_descriptor_files+=("${compose_service_filename}")
        fi

        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo -e "using remote deploy descriptor '${deploy_descriptor_path}' '${deploy_descriptor_files[@]}'"); fi

        for file in ${deploy_descriptor_files[@]}; do
            local optional="false"
            if [[ "${file}" == "docker-compose-base.yml" ]]; then optional="true"; fi
            download "${deploy_descriptor_path}/${file}" "${instance_dir}" "${file}" "${update}" "${optional}"

            # if docker-compose-base.yml not found, try src/main/resources/docker/docker-compose-base.yml
            if [[ ! -f "${instance_dir}/${file}" ]] && [[ "${file}" == "docker-compose-base.yml" ]]; then
                download "${deploy_descriptor_path}/src/main/resources/docker/${file}" "${instance_dir}" "${file}" "${update}" "${optional}"
            fi
        done
    elif [[ "${deploy_descriptor_path}" == image* ]]; then
    # image:
        deploy_descriptor_path="${deploy_descriptor_path#image:}"
        if [[ ${#deploy_descriptor_files[@]} -eq 0 ]]; then
            deploy_descriptor_files+=("deploy.zip")
        fi

        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo -e "using in-image deploy descriptor '${deploy_descriptor_path}' '${deploy_descriptor_files[@]}'"); fi

        #local docker_registry="$(instance-variables "${instance}" "DOCKER_REGISTRY")"
        local image_name=""
        local fully_qualified_image_name="$(instance-variables "${instance}" "FULLY_QUALIFIED_IMAGE_NAME")"
        if [[ -n "${fully_qualified_image_name}" ]]; then
            image_name="${fully_qualified_image_name}"
        else
            local image_prefix="$(instance-variables "${instance}" "IMAGE_PREFIX")"
            local image_tag="${IMAGE_TAG}"
            if [[ -z "${image_tag}" ]]; then image_tag="$(instance-variables "${instance}" "IMAGE_TAG")"; fi
            image_name="${image_prefix}${instance_service}:${image_tag}"
        fi

        #if [[ -z "${docker_registry}" ]]; then docker_registry="$(echo "${image_name}" | awk -F/ '{print $1}')"; fi
        #local docker_registry_auth=$(cat ~/.docker/config.json | jq -r '.auths?' | jq -r ".\"${docker_registry}\"?" | jq -r '.auth?')
        #if [[ "${docker_registry}" != http* ]]; then docker_registry="https://${docker_registry}"; fi
        #curl -H "Accept: application/vnd.docker.distribution.manifest.v2+json" "http://$server/v2/$repo/manifests/$tag" -H "Authorization: Basic ${docker_registry_auth}"

        (>&2 ${CMD_DOCKER} pull "${image_name}")
        (>&2 echo "${CMD_DOCKER} pull \"${image_name}\"")

        (>&2 echo "${CMD_DOCKER} inspect --format='{{.Id}}' ${image_name} | awk -F: '{print \$2}'")
        local image_id="$(${CMD_DOCKER} inspect --format='{{.Id}}' "${image_name}" | awk -F: '{print $2}')"
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "image_name: '${image_name}', image_id: '${image_id}'"); fi

        if [[ -z "${image_id}" ]]; then (>&2 echo "[ERROR] id of image ${image_name} not found, exit."); exit 1; fi

        local container_name="c_$(echo "${image_id}" | cut -c1-8)"
        (>&2 echo "${CMD_DOCKER} rm -fv ${container_name} 1>&2 > /dev/null")
        ${CMD_DOCKER} rm -fv "${container_name}" 1>&2 > /dev/null
        (>&2 echo "${CMD_DOCKER} create --name ${container_name} ${image_id}")
        (>&2 ${CMD_DOCKER} create --name "${container_name}" "${image_id}")

        local tmp_dir="${instance_properties_dir}/${image_id}"
        mkdir -p "${tmp_dir}"
        for file in ${deploy_descriptor_files[@]}; do
            local source_file="${deploy_descriptor_path%/}/${file}"
            local target_file="${tmp_dir}/${file}"

            (>&2 echo "${CMD_DOCKER} cp ${container_name}:${source_file} ${target_file}")
            (>&2 ${CMD_DOCKER} cp "${container_name}:${source_file}" "${target_file}")
            if [[ ! -f "${target_file}" ]]; then (>&2 echo "[ERROR] ${target_file} not found, exit."); exit 1; fi
            if [[ "${file##*.}" == "zip" ]]; then (cd "${tmp_dir}"; unzip "${file}" 1>&2); fi

            if [[ "${file##*.}" == "yml" ]] || [[ "${file##*.}" == "yaml" ]]; then compose_service_filename="${file}"; fi
        done

        fix-permissions "${tmp_dir}"
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo sudo cp -pR "${tmp_dir}/." "${instance_dir}/"); fi
        sudo cp -pR "${tmp_dir}/." "${instance_dir}/"

        rm -rf "${tmp_dir}"
        (>&2 echo "${CMD_DOCKER} rm -fv ${container_name} 1>&2 > /dev/null")
        ${CMD_DOCKER} rm -fv "${container_name}" 1>&2 > /dev/null

        deploy_descriptor_files=("${compose_service_filename}")
    elif [[ -z "${deploy_descriptor_path}" ]]; then
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo -e "using local deploy descriptor ${instance_dir}/${compose_service_filename}"); fi
        deploy_descriptor_files=("${compose_service_filename}")
    fi

    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo sudo cp -pR "${instance_properties_dir}/." "${instance_dir}/"); fi
    sudo cp -pR "${instance_properties_dir}/." "${instance_dir}/"

    if [[ -z "${deploy_descriptor_path}" ]] && [[ ! -f ${instance_dir}/${compose_service_filename} ]]; then
        (>&2 echo "[ERROR] no deploy descriptor specified and ${compose_service_filename} not found in instance directory ${instance_dir}, exit.")
        exit 1;
    fi

    local result=()
    for deploy_descriptor_file in ${deploy_descriptor_files[@]}; do
        result+=("${instance_dir}/${deploy_descriptor_file}")
    done

    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo -e "# <<<<<<<<<<<<<<<<<<<< instance-deploy-config <<<<<<<<<<<<<<<<<<<<\n"); fi
    echo "${result[@]}"
}

# arguments: $1: instance (host/service/instance_name or instance_name.service)
# returns: path of instance runtime config and data
function instance-dir() {
    local instance="$(normalize-instance "$1")"

    if [[ -n "${instance}" ]]; then
        local environment="$(environment)"
        local instance_dir="${DEPLOY_INSTANCES}/${environment}/$(echo "${instance}" | awk -F/ '{print $3"."$2}')"
        echo "${instance_dir}"
    fi
}

# arguments: $1: instance (host/service/instance_name or instance_name.service)
# returns: path of instance.properties
function instance-properties() {
    local instance="$(normalize-instance "$1")"

    local environment="$(environment)"
    local instance_properties="${DEPLOY_DOT_CONFIG_ENVIRONMENTS}/${environment}"
    if is_standalone_instance "${instance}" ; then
        instance_properties="${instance_properties}/$(echo ${instance} | awk -F/ '{print $1"/"$2}')/instance.properties"
    else
        instance_properties="${instance_properties}/${instance}/instance.properties"
    fi

    echo "${instance_properties}"
}

# arguments: $1: instance (host/service/instance_name or instance_name.service)
# returns: parent directory of instance.properties
function instance-properties-dir() {
    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo -e "\n\n# >>>>>>>>>>>>>>>>>>>> instance-properties-dir >>>>>>>>>>>>>>>>>>>>"); fi

    local instance="$(normalize-instance "$1")"
    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "instance: ${instance}"); fi

    local instance_properties="$(instance-properties "${instance}")"
    local instance_properties_dir="$(dirname "${instance_properties}")"

    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "instance_properties_dir ${instance_properties_dir}"); fi
    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo -e "# <<<<<<<<<<<<<<<<<<<< instance-properties-dir <<<<<<<<<<<<<<<<<<<<\n"); fi

    echo "${instance_properties_dir}"
}

# arguments: $1: instance (host/service/instance_name or instance_name.service)
# returns: service_name of instance
function instance-service() {
    local instance="$(normalize-instance "$1")"
    echo ${instance} | awk -F/ '{print $2}'
}

# arguments: $1: instance (host/service/instance_name or instance_name.service) or service (without host and instance_name), [$2: variable_name to read]
# returns: env file path of instance or variable value if $2 provided
function instance-variables() {
    local variable_name=""
    local variable_value=""
    if [[ "$2" != -* ]]; then variable_name="$2"; fi

    local _opt_verbose="${opt_verbose}";
    if [[ -n "${variable_name}" ]]; then opt_verbose="false"; fi
    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo -e "\n    # >>>>>>>>>>>>>>>>>>>> instance-variables ${variable_name} >>>>>>>>>>>>>>>>>>>>"); fi

    local is_instance="false"
    if [[ "$1" == */* ]] || [[ "$1" == *.* ]]; then is_instance="true"; fi

    local instance=""
    local instance_properties=""
    local environment_dir=""
    local instance_service=""
    local properties_files=()
    if [[ "${is_instance}" == "true" ]]; then
        instance="$(normalize-instance "$1")"
        local instance_properties_dir="$(instance-properties-dir "${instance}")"
        instance_properties="${instance_properties_dir}/instance.properties"
        local host_dir=""
        if is_standalone_instance "${instance}" ; then
            host_dir="$(dirname ${instance_properties_dir})"
        else
            host_dir="$(dirname $(dirname ${instance_properties_dir}))"
        fi

        environment_dir="$(dirname "${host_dir}")"

        local host_properties="${host_dir}/host.properties"
        if [[ ! -f ${instance_properties} ]]; then (>&2 echo "[ERROR] instance.properties (${instance_properties}) not found."); return 1; fi

        instance_service="$(instance-service "${instance}")"

        properties_files+=("${environment_dir}/environment.properties")
        properties_files+=("${host_properties}")
    else
        environment_dir="$(environment "dir")"
        instance_service="$1"

        properties_files+=("${environment_dir}/environment.properties")
    fi

    # remove last -*
    local instance_service_parent="${instance_service}"
    local next_instance_service_parent="$(echo "${instance_service_parent%-*}")"
    local tmp_parent_properties_files=()
    while [[ "${next_instance_service_parent}" != "${instance_service_parent}" ]]; do
        instance_service_parent_properties="${environment_dir}/${next_instance_service_parent}.properties"
        if [[ -f "${instance_service_parent_properties}" ]]; then tmp_parent_properties_files+=("${instance_service_parent_properties}"); fi

        instance_service_parent="${next_instance_service_parent}"
        next_instance_service_parent="$(echo "${instance_service_parent%-*}")"
    done

    # eg. tmp_parent_properties_files=("guardian-face" "guardian")
    # The priority should be "guardian" < "guardian-face", so append reversed tmp_parent_properties_files to properties_files.
    for ((i=${#tmp_parent_properties_files[@]}-1; i>=0; i--)); do
        properties_files+=("${tmp_parent_properties_files[$i]}")
    done

    properties_files+=("${environment_dir}/${instance_service}.properties")
    if [[ "${is_instance}" == "true" ]] && [[ -n "${instance_properties}" ]]; then
        properties_files+=("${instance_properties}")
    fi

    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "    export properties from ${properties_files[@]} to environment variables"); fi

    # see: https://stackoverflow.com/questions/1853946/getting-the-last-argument-passed-to-a-shell-script
    #for properties_files; do true; done
    local env_file=""
    if [[ "${is_instance}" == "true" ]]; then
        env_file="${instance_properties%.*}.env"
    else
        env_file="${environment_dir}/${instance_service}.env"
    fi
    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "    env_file ${env_file}"); fi

    echo '' | tee ${env_file} > /dev/null
    for properties_file in ${properties_files[@]}; do
        echo -e "\n\n# >>>>>>>>>>>>>>>>>>>> ${properties_file} >>>>>>>>>>>>>>>>>>>>\n" >> ${env_file}
        if [[ -f ${properties_file} ]]; then
            cat ${properties_file} >> ${env_file}
        fi
        echo -e "\n# <<<<<<<<<<<<<<<<<<<< ${properties_file} <<<<<<<<<<<<<<<<<<<<\n\n" >> ${env_file}
    done

    set -f
    if [[ "${is_instance}" == "true" ]]; then
        local current_host="$(current-host)"
        typeset -gx DEPLOY_CURRENT_HOST_IPADDRESS="$(eval echo ${current_host})"
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "    "property DEPLOY_CURRENT_HOST_IPADDRESS=\"${DEPLOY_CURRENT_HOST_IPADDRESS}\"); fi
        typeset -gx DEPLOY_INSTANCE_CONTAINER_HOST_NAME="$(eval echo "${instance}" | awk -F/ '{print $3"."$2}')"
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "    "property DEPLOY_INSTANCE_CONTAINER_HOST_NAME=\"${DEPLOY_INSTANCE_CONTAINER_HOST_NAME}\"); fi
        typeset -gx DEPLOY_INSTANCEID="$(eval echo "${instance_service}:$(echo "${instance}" | awk -F/ '{print $3}'):${current_host}")"
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "    "property DEPLOY_INSTANCEID=\"${DEPLOY_INSTANCEID}\"); fi

        # labels
        local config_version=$(version "${environment_dir}")
        local config_commit=$(echo "${config_version}" | awk -F^ '{print $1}')
        local config_ref=$(echo "${config_version}" | awk -F^ '{print $2}')
        typeset -gx LABEL_DEPLOY_CONFIG_COMMIT="$(eval echo ${config_commit})"
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "    "property LABEL_DEPLOY_CONFIG_COMMIT=\"${LABEL_DEPLOY_CONFIG_COMMIT}\"); fi
        local environment="$(environment)"
        typeset -gx LABEL_DEPLOY_CONFIG_NAME="$(eval echo ${environment})"
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "    "property LABEL_DEPLOY_CONFIG_NAME=\"${LABEL_DEPLOY_CONFIG_NAME}\"); fi
        typeset -gx LABEL_DEPLOY_CONFIG_REF="$(eval echo ${config_ref})"
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "    "property LABEL_DEPLOY_CONFIG_REF=\"${LABEL_DEPLOY_CONFIG_REF}\"); fi
        local util_version=$(version)
        local util_commit=$(echo "${util_version}" | awk -F^ '{print $1}')
        local util_ref=$(echo "${util_version}" | awk -F^ '{print $2}')
        typeset -gx LABEL_DEPLOY_UTIL_COMMIT="$(eval echo ${util_commit})"
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "    "property LABEL_DEPLOY_UTIL_COMMIT=\"${LABEL_DEPLOY_UTIL_COMMIT}\"); fi
        typeset -gx LABEL_DEPLOY_UTIL_REF="$(eval echo ${util_ref})"
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "    "property LABEL_DEPLOY_UTIL_REF=\"${LABEL_DEPLOY_UTIL_REF}\"); fi
        typeset -gx LABEL_INSTANCE_NAME="$(eval echo ${instance})"
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "    "property LABEL_INSTANCE_NAME=\"${LABEL_INSTANCE_NAME}\"); fi
        local instance_short="$(echo "${instance}" | awk -F/ '{print $3"."$2}')"
        typeset -gx LABEL_INSTANCE_NAME_SHORT="$(eval echo ${instance_short})"
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "    "property LABEL_INSTANCE_NAME_SHORT=\"${LABEL_INSTANCE_NAME_SHORT}\"); fi
    fi
    set +f

    # for every line that not comment or blank
    # IFS='' is for lines with space
    while IFS= read -r line; do
        #(>&2 printf "    %s\n" "$line")

        if [[ -n "$(echo ${line} | grep -Ev '^\s*#.*' | grep -Ev '^\s*$')" ]]; then
            # split line by first equals sign
            local name=$(cut -d '=' -f 1 <<< "${line}")
            local value=$(cut -d '=' -f 2- <<< "${line}")
            if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "    found property name: \"${name}\", value: \"${value}\""); fi

            set -f
            if [[ -z "${variable_name}" ]]; then
                typeset -gx ${name}="$(eval echo ${value})"
                if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "all    ""                      "${name}=\"$(eval echo \$${name})\"); fi
            elif [[ "${variable_name}" == "${name}" ]]; then
                #typeset -x ${name}="$(eval echo ${value})"
                #variable_value="$(eval echo \$${name})"
                #if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "var    ""                      "${name}=\"$(eval echo \$${name})\"); fi
                variable_value="$(eval echo ${value})"
                if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "var    ""                      "${name}=\"${variable_value}\"); fi
            else
                typeset -x ${name}="$(eval echo ${value})"
                if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "tmp    ""                      "${name}=\"$(eval echo \$${name})\"); fi
            fi
            set +f
        fi
    done < ${env_file}

    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo -e "    # <<<<<<<<<<<<<<<<<<<< instance-variables ${variable_name} <<<<<<<<<<<<<<<<<<<<\n"); fi
    opt_verbose="${_opt_verbose}"

    if [[ -z "${variable_name}" ]]; then echo "${env_file}"; else echo "${variable_value}"; fi
}

function list() {
    local environment="$(environment)"
    local result=()
    if [[ "${opt_short}" == "true" ]]; then
        result=($(sudo find -L ${DEPLOY_INSTANCES}/${environment} -maxdepth 3 -mindepth 2 -type f -name 'instance.properties' -printf '%P\n' 2>/dev/null | awk -F/ '{print $1}' | awk -F. '{print $2"/"$1}' | sort | awk -F/ '{print $2"."$1}'))
    else
        local found=($(sudo find -L ${DEPLOY_INSTANCES}/${environment} -maxdepth 3 -mindepth 2 -type f -name 'instance.properties' -printf '%P\n' 2>/dev/null | awk -F/ '{print $1}' | awk -F. '{print $2"/"$1}' | sort | awk -F/ '{print $2"."$1}'))
        for instance in ${found[@]}; do result+=("$(normalize-instance "${instance}")"); done
    fi

    printf '%s\n' "${result[@]}"
}

# arguments: $1: instance (host/service/instance_name or instance_name.service)
# returns: host/service/instance_name
function normalize-instance() {
    local instance="$1"
    local result=()

    if [[ "${instance}" =~ ^[^/]+/[^/]+/[^/]+$ ]]; then
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "normalize-instance '${instance}' 'matched ^[^/]+/[^/]+/[^/]+$' (long instance name)"); fi
        result=("${instance}")
    elif [[ "${instance}" =~ ^[^.]+\.[^.]+$ ]]; then
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "normalize-instance '${instance}' 'matched ^[^.]+\.[^.]+$' (short instance name)"); fi
        local instance_without_host="$(echo ${instance} | awk -F. '{print $2"/"$1}')"
        if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "instance_without_host '${instance_without_host}'"); fi

        _opt_all="${opt_all}"
        local _opt_verbose="${opt_verbose}"
        opt_all="true"
        opt_verbose="false"
        local result=($(search | grep "/${instance_without_host}\$"))
        opt_all="${_opt_all}"
        opt_verbose="${_opt_verbose}"
        if [[ -z "${result}" ]] && [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "[WARN] instance '${instance_without_host}' not found"); fi
    fi

    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "result '${result[@]}'"); fi
    printf '%s\n' "${result[@]}" | head -n 1
}

function search() {
    local standalone_instances=($(search-standalone-instances))
    local named_instances=($(search-named-instances))

    if [[ ${#standalone_instances[@]} -gt 0 ]]; then printf '%s\n' "${standalone_instances[@]}"; fi
    if [[ ${#named_instances[@]} -gt 0 ]]; then printf '%s\n' "${named_instances[@]}"; fi
}

# returns: a sorted list of host/service/instance_name or instance_name.service (short), no uniq on duplicate entries
function search-named-instances() {
    local environment="$(environment)"

    local found=($(sudo find -L ${DEPLOY_DOT_CONFIG_ENVIRONMENTS}/${environment} -maxdepth 4 -mindepth 4 -type f -name 'instance.properties' -printf '%P\n'))
    if [[ "${opt_all}" != "true" ]] && [[ ${#found[@]} -gt 0 ]]; then found=($(printf '%s\n' "${found[@]}" | grep "$(current-host)/")); fi
    local named_instances=()
    if [[ ${#found[@]} -gt 0 ]]; then
        if [[ "${opt_short}" == "true" ]]; then
            named_instances+=($(printf '%s\n' "${found[@]}" | awk -F/ '{print $2"/"$3}' | sort | awk -F/ '{print $2"."$1}'))
        else
            named_instances+=($(printf '%s\n' "${found[@]}" | awk -F/ '{print $1"/"$2"/"$3}' | sort))
        fi
    fi

    printf '%s\n' "${named_instances[@]}"
}

# returns: a sorted list of host/service/standalone or standalone.service (short), no uniq on duplicate entries
function search-standalone-instances() {
    local environment="$(environment)"

    local found=($(sudo find -L ${DEPLOY_DOT_CONFIG_ENVIRONMENTS}/${environment} -maxdepth 3 -mindepth 3 -type f -name 'instance.properties' -printf '%P\n'))
    if [[ "${opt_all}" != "true" ]] && [[ ${#found[@]} -gt 0 ]]; then found=($(printf '%s\n' "${found[@]}" | grep "$(current-host)/")); fi

    local standalone_instances=()
    if [[ ${#found[@]} -gt 0 ]]; then
        if [[ "${opt_short}" == "true" ]]; then
            standalone_instances=($(printf '%s\n' "${found[@]}" | awk -F/ '{print $2"/standalone"}' | sort | awk -F/ '{print $2"."$1}'))
        else
            standalone_instances=($(printf '%s\n' "${found[@]}" | awk -F/ '{print $1"/"$2"/standalone"}' | sort))
        fi
    fi

    printf '%s\n' "${standalone_instances[@]}"
}

function update() {
    local commit="latest"
    if [[ -n "${opt_commit}" ]]; then commit="${opt_commit}"; fi
    git_checkout "${DIR}" "${commit}"
}

# arguments: $1 local repository
function version() {
    local local_repo="$1"
    if [[ -z "${local_repo}" ]]; then local_repo=${DIR}; fi

    # branch or tag name
    local commit=$(git -C ${local_repo} rev-parse --verify HEAD)
    local ref=$(git -C ${local_repo} symbolic-ref -q --short HEAD || git -C ${local_repo} describe --tags --exact-match)
    echo "${commit}^${ref}"
}

default_cmd="commands"
_commands=()
_commands+=("${default_cmd}")
_commands+=("environment")
_commands+=("environments")
_commands+=("install")
_commands+=("version")
if [[ -n "$(environment)" ]]; then
    _commands+=("clean")
    _commands+=("current-host")
    _commands+=("docker-compose")
    _commands+=("doctor")
    _commands+=("fix-permissions")
    _commands+=("instance-deploy-config")
    _commands+=("instance-dir")
    _commands+=("instance-properties")
    _commands+=("instance-properties-dir")
    _commands+=("instance-service")
    _commands+=("instance-variables")
    _commands+=("list")
    _commands+=("normalize-instance")
    _commands+=("search")
    _commands+=("search-named-instances")
    _commands+=("search-standalone-instances")
    _commands+=("update")
fi

if [[ "${sourced_or_run}" == "run" ]]; then
    # $1: function name (optional), $2: service, $3: instance (docker/docker-compose container/host name) (optional), $4...: additional commands and args to function
    if [[ ${#args[@]} -gt 0 ]] && [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "${#args[@]} script arguments: '${args[@]}'"); fi

    _cmd=""
    for c in ${_commands[@]}; do if [[ "${args[0]}" == "${c}" ]]; then _cmd="${c}"; remove_arg "${args[0]}"; break; fi; done
    if [[ -z "${_cmd}" ]]; then _cmd="${default_cmd}"; fi

    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo "deploy" "${_cmd}" "${args[@]}"); fi
    if [[ "${opt_verbose}" == "true" ]]; then (>&2 echo -e "# <<<<<<<<<<<<<<<<<<<< options and commands <<<<<<<<<<<<<<<<<<<<\n"); fi
    ${_cmd} "${args[@]}"
fi
